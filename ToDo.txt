-------------------------------------------------
# TONY ToDo List
-------------------------------------------------

[x] Keyboard - Map Dateien erstellen -> Sind Größenbegrenzt (z.B. 2kb) und enhalten Informationen und Tabellen zur Verarbeitung von Scan Codes -> Struktur überlegen (default DE)
[x] Keyboard getch 
[x] und readln
[x] Keyboard auf extended scan codes reagieren -> Tabelle erweitern
[x] Keyboard .check_key_modifier auf interrupt umstellen -> Suche in Keymap nach Funktionstasten -> Nach Funktionstastencode -> nach Scancode (erweitert? => OFFSET!) in Keystate table und erstelle interrupt zur Abfrage von Sondertasten (mit Funktionen ah=0 al = ESC - DRUCK, ah=1 al = EINFG - BILD Runter) -> setze oder lösche carry und ersetzte .check_special_keys aktuell mit  Aufruf und carry Prüfung 
[x] Keyboard vor .check_key_modifier prüfen, ob Funktionstaste, falls ja verlassen, da im folgenden nur noch ASCII Umwandlung stattfindet
[ ] Keyboard Capslock und numlock (inkl. leds)
[x] Kernel Config Reader
    [x] Lesen von Keyboard Map und entsprechend laden (an bestimmte Stelle in Keyboard Driver laden)
[x] Memory Map anlegen -> 0x000000 - 0x07ffff (8 Segmente) programmierbar (524288B = 512kB) -> Map in Kernel mit 4kB, jedes Bit gibt an, ob 16 Byte im Bereich 0x00000-0x07ffff frei sind -> Speicher in 16 Byte große Einheiten zerlegt (kleinst möglich)
    [x] Interrupt nimmt Anzahl benötigter Bytes entgegen, und gibt Pointer zurück
    [x] Delete Interrupt nimmt Anzahl benötigter Bytes und Pointer entgegen 
[] Machine Monitor vgl. Apple 2 -> lesen (Zahl eingeben) von N Byte (zahl1-zahl2), schreiben von N Byte (addr: zahl1 zahl2...), ausführen an bestimmter Stelle (zahlR/zahlG)
[] Mini disassembler -> zahlL bzw. zahl1-zahl2L 
[] Mini Assembler ! Startet Assembler (! Ist prompt) ->!addr Befehl, folgebefehle mit ! Befehl -> Leerzeichen gibt folgebefehl an -> Assembler gibt opcode aus -> Tabelle 
[x] Kernel Config Reader
    [ ] Lesen von Shell Datei und entsprechend in freien Speicher laden und ausführen 
[ ] File open interrupt gibt file zurück mit Adresse, Anfangsposition fat, aktuelles Cluster der Datei im Speicher ; mit file read line interrupt bis eof durch Datei lesen ; mit write Schreiben und mit close Speicher freigeben 
[ ] Fallout Hacking Login Game -> Über Kernelconfig als shell ladbar -> Lädt dann wiederum shell
[ ] Berechnungen und Vergleiche für 32-Bit Zahlen
[ ] String to int
[ ] int to String
[x] Ausführung von COM Dateien Interrupt einbauen
    Dateigröße reservieren
    Listenelement hinzufügen (Erstes Listenelement in Variable speichern)
        Listenelementgröße: 16 Byte
        Segment + Offset von Filehandle des aufzurufenden Programms
        Segment + Offset von Stack vor dem Aufruf des Unterprogramms
        Segment + Offset des nächsten Listenelements (0xfffff), falls Ende der Liste
    Interrupt zum Beenden an Offset 0 schreiben
    PSP füllen
    DS und ES auf Offset anpassen
    word 0 auf Stack schreiben -> Beim RET wird zu Offset 0 gesprungen -> Verlassen interrupt
    Hardware Interrupts aktivieren (sti), damit diese während der Ausführung von Programmen aufgerufen werden
    Sprung an Offset 0x100
    Kein Iret, COM werden mit Verlassen interrupt verlassen -> Kommentar schreiben
[x] Verlassen Interrupt für Unterprozess
    Taskliste ab erstem Element durchlaufen, bis Segment + Offset des Files des aufgerufenen Programms mit CS und IP aus dem Stack übereinstimmen
        Speicher von Datei freigeben -> Dazu COM aus Listenelement suchen + 0x100 für psp und deallokieren
        Listenelement ausketten -> bei letztem Listenelement Vars auf 0 setzen
        Stack aus Segment und Offset aus Listenelement wieder herstellen
        Listenelementspeicher freigeben
    Iret kehrt zum Aufruf von Interrupt zur Ausführung von COM zurück, da dort kein Iret ausgeführt wird
[ ] Interrupt exceptions umprogrammieren -> Fehlermeldung geben / aktuelles Programm beenden
    Ab Interrupt exception 8 (auch hardware interrupt) im pic prüfen, ob hardware interrupt, falls nicht exception
[ ] Warnung ausgeben, wenn Datei aus Kernel cfg nicht gefunden -> ggf. kein Grafikmodus starten 
Bei Fehlender Keyboard Datei halten